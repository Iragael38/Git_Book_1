[
["index.html", "A Book for Statistics Chapter 1 Prerequisites 1.1 Compile the book in local 1.2 Push on Github", " A Book for Statistics I Joly 2019-12-13 Chapter 1 Prerequisites 1.1 Compile the book in local bookdown::render_book(\"index.Rmd\", \"bookdown::gitbook\") 1.2 Push on Github git commit -m \"Started book\" git push -u origin master Remember each Rmd file contains one and only one chapter, and a chapter is defined by the first-level heading #. To compile this example to PDF, you need XeLaTeX. You are recommended to install TinyTeX (which includes XeLaTeX): https://yihui.name/tinytex/. "],
["Preface.html", "Chapter 2 Preface 2.1 To Do List 2.2 A mettre en place 2.3 Rappels d’édition", " Chapter 2 Preface library(ggplot2);library(knitr) 2.1 To Do List Voir multioutput : pdf + html Theme Tufte Insert de Shiny Faire un pdf: Rscript -e \"bookdown::render_book('index.Rmd', 'bookdown::pdf_book')\" 2.2 A mettre en place fig_aption=TRUE dans le Yalm, mais où ? split_by split en plusieurs fichiers HTML (par rmd, chapter section none chapter+number section+number) split_bib= T or F pour bib en fin de chaque page ou fin de doc 2.3 Rappels d’édition You can label chapter and section titles using {#label} after them, e.g., we can reference Chapter 2. If you do not manually label them, there will be automatic labels anyway, e.g., Chapter ??. Figures and tables with captions will be placed in figure and table environments, respectively. par(mar = c(4, 4, .1, .1)) plot(pressure, type = &#39;b&#39;, pch = 19) Figure 2.1: Here is a nice figure! Reference a figure by its code chunk label with the fig: prefix, e.g., see Figure 2.1. Similarly, you can reference tables generated from knitr::kable(), e.g., see Table 2.1. knitr::kable( head(iris, 20), caption = &#39;Here is a nice table!&#39;, booktabs = TRUE ) Table 2.1: Here is a nice table! Sepal.Length Sepal.Width Petal.Length Petal.Width Species 5.1 3.5 1.4 0.2 setosa 4.9 3.0 1.4 0.2 setosa 4.7 3.2 1.3 0.2 setosa 4.6 3.1 1.5 0.2 setosa 5.0 3.6 1.4 0.2 setosa 5.4 3.9 1.7 0.4 setosa 4.6 3.4 1.4 0.3 setosa 5.0 3.4 1.5 0.2 setosa 4.4 2.9 1.4 0.2 setosa 4.9 3.1 1.5 0.1 setosa 5.4 3.7 1.5 0.2 setosa 4.8 3.4 1.6 0.2 setosa 4.8 3.0 1.4 0.1 setosa 4.3 3.0 1.1 0.1 setosa 5.8 4.0 1.2 0.2 setosa 5.7 4.4 1.5 0.4 setosa 5.4 3.9 1.3 0.4 setosa 5.1 3.5 1.4 0.3 setosa 5.7 3.8 1.7 0.3 setosa 5.1 3.8 1.5 0.3 setosa You can write citations, too. For example, we are using the bookdown package [R-bookdown] in this sample book, which was built on top of R Markdown and knitr [xie2015]. "],
["premieres-operations-sous-r.html", "Chapter 3 Premières opérations sous R 3.1 Les packages 3.2 Working directory: dossier de travail 3.3 Codage R:", " Chapter 3 Premières opérations sous R 3.1 Les packages R a une configuration de base, qui peut être complétée par de nombreux packages ajoutant différentes fonctions. Les packages doivent être installés une première fois sur le pc avant de pouvoir être utilisés. install.packages(\"pack\") téléchargera est installera le package.1 Les packages installés sur une machine ne sont pas chargés en mémoire au démarrage. On charge les packages requis dans l’environnement R par library() ou require() Les fonctions et les données contenus dans le package sont alors accessibles. Le package installrpropose la fonction updateR(), qui met automatiquement à jour la version de R et les packages. 3.2 Working directory: dossier de travail Sans précision particulière, les fichiers seront chargés et sauvegardés dans le working directory (wd): le dossier dans lequel R va stocker et rechercher les fichiers. Les fonctions getwd() et setwd() permettent respectivement de voir le dossier de travail actuel et de le modifier. R utilise un autre type d’écriture de chemin d’accès que celui de Windows (\"C:\\Dossier\\sous-dossier\"). Sous R, il faut utiliser \"C:/Dossier/sous-dossier\" ou \"C:\\\\Dossier\\\\sous-dossier\". Et sous Mac : \"/Users/Moi/Dossier/\" 3.3 Codage R: Le code R peut être saisi directement dans la console ligne à ligne ou être sauvé comme un script: une succession de lignes de code. Un script peut être sauvegardé dans un fichier d’extension .R. Un script peut être exécuté de plusieurs façons: en gardant le curseur sur la ligne à exécuter et en cliquant sur le bouton run (ou avec le raccourcis clavier CTRL+ENTREE). Après éxecution, le curseur passe à la ligne suivante. en sélectionnant la ou les lignes à exécuter et en cliquant sur run (ou CTRL+ENTREE) par la fonction source(\"monscript.R\"). Les commandes dans le script sont séparées soit par ; soit par un retour à la ligne R is case sensitive. Majuscules et minuscules sont prises en compte dans les noms de fonctions, d’objets, etc. Le caratère # précède des éléments de commentaires et ne sont pas exécutés. Certaines commandes s’étendent sur plusieurs lignes. On utilise + à la fin d’une ligne pour une commande multilignes. R stocke les données et les résultats dans des objets. On assigne et on stocke dans des objets avec l’opérateur &lt;-. Pour afficher le contenu d’un objet, il suffit d’exécuter son nom. Pour afficher tous les objets de l’environnement (ou la mémoire de R) : ls() Par exemple: # stocke 3 dans l&#39;objet abc abc &lt;- 3 # affiche le contenu de abc abc ## [1] 3 # affiche le contenu de l&#39;environnement ls() ## [1] &quot;abc&quot; Les fonctions sont essentielles pour le travail des données sous R. Comme pour les fonctions mathématiques, les fonction R réalisent des opérations sur un input et renvoient un output. Par exemple, la fonction mean(x) prend le vecteur de nombres x et renvoie leur moyenne. Les inputs sont souvent appelés des arguments de la fonction. L’aide et la documentation des fonctions et des objets de R sont accessibles par ? Par exemple ?mean voir le fichier install.packages.R qui regroupe les packages utilisés pour ce cours et ceux conseillés.↩ "],
["manipulation-des-objets-sous-r.html", "Chapter 4 Manipulation des objets sous R 4.1 Structures de données 4.2 Les Vecteurs 4.3 Recyclage vectoriel 4.4 Sélectionner des sous-ensembles de vecteur avec [] 4.5 Sélection conditionnelle - sous ensemble conditionné 4.6 Listes 4.7 Matrices 4.8 Dataframe", " Chapter 4 Manipulation des objets sous R 4.1 Structures de données Plusieurs types d’objets de R peuvent contenir des données. 4.2 Les Vecteurs Les vecteurs sont unidimentionnels et homogènes. Une variable seule peut être représentée par un vecteur de l’un des types suivants: - logical: la variable prend les valeurs TRUE ou FALSE (1 ou 0) - integer: un entier uniquement (représenté par un nombre suivi de L) - numeric ou double: un nombre réel - character: une chaine de caractères (du texte) Une valeur seule est un vecteur de longueur 1. c() est la fonction de concaténation. elle combine les valeurs de différents type en un vecteur. typeof() identifie le type du vecteur. length() renvoie la longueur du vecteur. Exemple: mon_vec &lt;- c(1, 3, 5) mon_vec ## [1] 1 3 5 typeof(mon_vec) ## [1] &quot;double&quot; char_vec &lt;- c(&quot;these&quot;, &quot;are&quot;, &quot;some&quot;, &quot;words&quot;) length(char_vec) ## [1] 4 Répétition et séquence rep() créé un vecteur en répétant les élements: seq() créé un vecteur en faisant une séquence d’éléments. L’expression m:n génère une séquence d’entiers de mà n Par exemple: # répéter 3 fois 0 rep(0, times=3) ## [1] 0 0 0 # répéter 4 fois &quot;abc&quot; rep(&quot;abc&quot;, 4) ## [1] &quot;abc&quot; &quot;abc&quot; &quot;abc&quot; &quot;abc&quot; # Séquence de 1 à 5 avec un pas de 2 seq(from=1, to=5, by=2) ## [1] 1 3 5 # Séquence de 10 à 0 avec un pas de -5 seq(10, 0, -5) ## [1] 10 5 0 # Séquence d&#39;entiers de 3 à 7 3:7 ## [1] 3 4 5 6 7 # Répétition de séquence: rep(seq(1,3,1), times=2) ## [1] 1 2 3 1 2 3 # Séquence de répétition rep(seq(1,3,1), each=2) ## [1] 1 1 2 2 3 3 4.3 Recyclage vectoriel Lorsque des opérations sont réalisées sur deux vecteurs ou plus, dont les dimensions sont inégales, les valeurs du vecteur le plus court seront ‘recyclées’ pour compléter le vecteur jusqu’à obtenir la même dimension que le vecteur le plus long. Dans l’exemple ci-dessous, le vecteur c(1) de taille 1 est recyclé pour devenir c(1,1,1) c(1,2,3) + 1 ## [1] 2 3 4 Ici, le vecteur c(1,2) est recyclé deux fois pour devenir c(1,2,1,2,1,2) c(1,2,3,4,5,6) + c(1,2) ## [1] 2 4 4 6 6 8 c(2) devient c(2,2,2) c(1,2,3) &lt; 2 ## [1] TRUE FALSE FALSE Si le recyclage est partiel, on a le message c(2,3,4) + c(10, 20) ## Warning in c(2, 3, 4) + c(10, 20): la taille d&#39;un objet plus long n&#39;est pas ## multiple de la taille d&#39;un objet plus court ## [1] 12 23 14 4.4 Sélectionner des sous-ensembles de vecteur avec [] Les éléments composant un vecteur peuvent être sélectionnés en spécifiant sa position dans le vecteur entre [] # créer un vecteur de 10 à 1 a &lt;- seq(10,1,-1) ; a ## [1] 10 9 8 7 6 5 4 3 2 1 Par exemple : Sélectionner le 2ème élément a[2] ## [1] 9 Sélectionner les 5 premiers éléments a[seq(1,5)] ## [1] 10 9 8 7 6 Sélection des premier, troisième et quatrième éléments: a[c(1,3,4)] ## [1] 10 8 7 Les éléments peuvent être nommés, et appelés par leur nom. scores &lt;- c(John=25, Marge=34, Dan=24, Emily=29) scores[c(&quot;John&quot;, &quot;Emily&quot;)] ## John Emily ## 25 29 4.5 Sélection conditionnelle - sous ensemble conditionné Le subsetting logique peut être fait avec un vecteur (TRUE/FALSE) scores[c(FALSE, TRUE, TRUE, FALSE)] ## Marge Dan ## 34 24 Il peut aussi être fait avec une condition scores[scores&lt;30] ## John Dan Emily ## 25 24 29 4.6 Listes Les listes sont des éléments uni-dimensionnels, mais dont les éléments peuvent être de types différents : des vecteurs (de toute dimension), des listes, des matrices, des dataframes. Une liste composée d’un vecteur, d’un vecteur d’entiers et un vecteur de caractères. mylist &lt;- list(1.1, c(1L,3L,7L), c(&quot;abc&quot;, &quot;def&quot;)) mylist ## [[1]] ## [1] 1.1 ## ## [[2]] ## [1] 1 3 7 ## ## [[3]] ## [1] &quot;abc&quot; &quot;def&quot; Les éléments peuvent être nommés mary_info &lt;- list(classes=c(&quot;Biology&quot;, &quot;Math&quot;, &quot;Music&quot;, &quot;Physics&quot;), friends=c(&quot;John&quot;, &quot;Dan&quot;, &quot;Emily&quot;), SAT=1450) mary_info ## $classes ## [1] &quot;Biology&quot; &quot;Math&quot; &quot;Music&quot; &quot;Physics&quot; ## ## $friends ## [1] &quot;John&quot; &quot;Dan&quot; &quot;Emily&quot; ## ## $SAT ## [1] 1450 Comme précédemment, l’accès aux composants d’une liste se fait soit par [[]] pour accèder avec la position, soit avec $ pour accèder avec le nom. Par la position mary_info[[2]] ## [1] &quot;John&quot; &quot;Dan&quot; &quot;Emily&quot; Par le nom mary_info$SAT ## [1] 1450 Le second élément du vecteur friend mary_info$friends[2] ## [1] &quot;Dan&quot; 4.7 Matrices Les matrices sont des structures de données à deux dimensions et homogènes. L’input de matrix() est un vecteur qui est transformé en une matrice en 2 dimensions, selon les spécifications nrow et ncol. Par défaut, la matrice est remplie colonne par colonne, cela est modifié par byrow=T Par exemple: une matrice 2lx3c, remplie par colonne: # on remplit les colonnes avec le vecteur de 1 à 6 sur 2 lignes a &lt;- matrix(1:6, nrow=2) a ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 Remplissage par ligne b &lt;- matrix(5:14, nrow=2, byrow=TRUE) b ## [,1] [,2] [,3] [,4] [,5] ## [1,] 5 6 7 8 9 ## [2,] 10 11 12 13 14 L’omission de row correspond à la sélection de toutes les lignes. L’omission de column sélectionne toutes les colonnes. Sélection de la ligne 2, colonne 3 a[2,3] ## [1] 6 Toutes les lignes de la colonne 2 b[,2] ## [1] 6 11 Toutes les colonnes de la ligne 1 a[1,] ## [1] 1 3 5 4.8 Dataframe Les données de l’analyse statistique sont typiquement stockées dans des dataframe. Elles combinent les possibilités des matrices et des listes. Comme pour les matrices, les dataframe sont rectangulaires, les colonnes sont les variables et les lignes sont les observations de ces variables. Comme les listes, les dataframe peuvent avoir des éléments (les colonnes) de différents types (numérique, caractère, facteurs, logique,etc.) Mais les éléments d’un dataframe doivent être de longueur égale. La syntaxe est la même que pour list(), mais les éléments doivent être de même longueur. Les éléments peuvent être nommés. Par exemple, un vecteur logique et un vecteur numérique mydata &lt;- data.frame(diabetic = c(TRUE, FALSE, TRUE, FALSE), height = c(65, 69, 71, 73)) mydata ## diabetic height ## 1 TRUE 65 ## 2 FALSE 69 ## 3 TRUE 71 ## 4 FALSE 73 Comme pour les matrices et les listes, les sélections sont faites avec[rows, columns] ou avec le nom de la variable. Par exemple mydata[3,2] ## [1] 71 Ou mydata[1:2, &quot;height&quot;] ## [1] 65 69 Ou mydata[,&quot;diabetic&quot;] ## [1] TRUE FALSE TRUE FALSE \\textbf{Accéder aux variables ou colonnes par le nom ou $} Par exemple mydata$height[2:3] ## [1] 69 71 mydata[[&quot;height&quot;]] ## [1] 65 69 71 73 mydata[[&quot;height&quot;]][2] ## [1] 69 colnames(data_frame) renvoie les noms des colonnes d’une dataframe (ou d’une matrice). colnames(data_frame) &lt;- c(\"some\", \"names\") assigne des noms aux colonnes. Par exemple colnames(mydata) ## [1] &quot;diabetic&quot; &quot;height&quot; colnames(mydata) &lt;- c(&quot;Diabetic&quot;, &quot;Height&quot;) colnames(mydata) ## [1] &quot;Diabetic&quot; &quot;Height&quot; Pour changer le nom d’une variable: colnames(mydata)[1] &lt;- &quot;Diabetes&quot; colnames(mydata) ## [1] &quot;Diabetes&quot; &quot;Height&quot; Enfin on peut “copier/coller” une variable sous condition : dat[dat$Subject=='s2',]$RT &lt;- dat[dat$Subject=='s2',]$Trial Pour les objets à 2 dimensions dim() renvoie le nombre de lignes et de colonnes. On utilise str() pour connaître la structure d’un objet et le type de ses éléments. dim(mydata) ## [1] 4 2 str(mydata) ## &#39;data.frame&#39;: 4 obs. of 2 variables: ## $ Diabetes: logi TRUE FALSE TRUE FALSE ## $ Height : num 65 69 71 73 "],
["chargement-de-donnees-sous-r.html", "Chapter 5 Chargement de données sous R 5.1 Manipulation de données 5.2 Les packages 5.3 Working directory: dossier de travail 5.4 Codage R: 5.5 Structures de données 5.6 Les Vecteurs 5.7 Recyclage vectoriel 5.8 Sélectionner des sous-ensembles de vecteur avec [] 5.9 Sélection conditionnelle - sous ensemble conditionné 5.10 Listes 5.11 Matrices 5.12 Dataframe 5.13 Manipulation de données", " Chapter 5 Chargement de données sous R 5.1 Manipulation de données Débutant avec R, il peut sembler efficace de manipuler les données avec un logiciel familier tel que MS Excel, pour corriger les erreurs, ajouter quelques informations ou faire quelques calculs simples. Pourtant, le travail sous R est encouragé ici, pour 100% des opérations sur les données ! Quelques arguments: MS Excel charge les données réelles, ce qui signifie que les modifications sont sauvegardées dans le fichier de données même. De plus, aucun historique des manipulations n’est sauvegardé, il est donc difficile, voire impossible, de conserver une trace des changements. Au contraire, R, charge une copie des données dans sa mémoire et n’altère pas directement les données. Il permet de fonctionner avec des scripts, qui listent les manipulations appliquées aux données, les rendant ainsi reproductibles et transparentes. Travailler directement sur les données peut produire des erreurs qui sont alors difficiles à identifier et à corriger. Avec R il est facile de détecter les erreurs et problèmes systématiques à partir de petits programmes. Différents formats de données peuvent être chargés avec R, notamment les formats de logiciels spécialisés tels que SAS, Spss, Stata, etc. Dataframe Une base de données sous R est appelée une dataframe, équivalent à une matrice de données où les lignes sont indéxées par leur numéro et les colonnes par des noms de variables. Les bases de données d’autres formats (par ex. ceux d’autres logiciels) peuvent être importées (ou chargées) sous R. Formats de données R Les fichiers .Rdata ou .rda contiennent un ou plusieurs objets R (dataframes, fonctions, shapefiles, etc.) # Chargement d&#39;un fichier (fictif) de données dans R: load(&#39;DATA\\\\Movie.Data.Clean.RData&#39;) # utiliser ls() pour lister les objets de l&#39;environnement ls() ## [1] &quot;a&quot; &quot;abc&quot; &quot;b&quot; &quot;char_vec&quot; &quot;mary_info&quot; ## [6] &quot;mon_vec&quot; &quot;Movie.Data&quot; &quot;mydata&quot; &quot;mylist&quot; &quot;scores&quot; Les fichiers .rds contiennent un objet R sans nom. Cet objet est donc stocké dans une seule variable. readRDS('file.rds') permet de charger un tel fichier et str(newdat)de savoir quels objets sont dans l’objet chargé. Les fichers texte Les fichiers .txtou .csv sont des fichiers de données brutes, sans mise en forme des données (par exemple format de date). Dans un fichier texte, une ligne correspond à une observation (une ligne du dataframe). Sur la ligne, les valeurs des différentes colonnes sont séparées par un caractère séparateur (souvent le ; ou la tabulation). read.table('file.txt', header=TRUE) permet de charger un fichier texte où la 1ère ligne contient les noms de variables. Problèmes classiques de lecture des fichiers textes R ne trouve pas le fichier que vous voulez charger: Vérifiez votre working directory (dossier de travail) getwd(). Ce dossier contient-il le fichier que vous voulez charger ? Modifiez ce dossier avec setwd(). Parfois il est utile de préciser tout le chemin d’accès dans le nom du fichier à charger. Par exemple: \"C://Documents//data.txt\" sous Windows ou sous Mac \"/Users/Moi/Documents/data.txt\". Incorrect delimiter. Aucun message d’erreur n’est affiché, mais les données paraissent étranges. Le séparateur de variable est mal spécifié. Excel utilise souvent la , alors que d’autres logiciels utilisent l’espace ou la tabulation. dat &lt;- read.table(\"file.csv\", header=TRUE, sep=',')permet de préciser le séparateur. Décimale. Les données issues de locigiels anglosaxons utilisent le . pour indiquer les décimales, plutôt que la ,. Cela peut être précisé avec: dat &lt;- read.table(\"file.csv\", header=TRUE, sep=',', dec='.') Cependant, le . est aussi parfois utilisé pour séparer les milliers. C’est alors à l’exportation des données que l’on doit s’assurer du caractère des décimales et qu’il n’y a pas de caractère pour les milliers. Erreurs sur les variables. Dans certains cas, le problème d’importation affecte une ou plusieurs variables. Une chaine de caractère est reconnue comme un facteur : as.character(data$V1) pour convertir une variable en caractère. Dans un champs de caractère, le . est utilisé pour les milliers, alors que la ,marque les décimales. gsub(\"\\\\.\", \"\", data$V1)supprime les . dans le champs de valeurs. La ,marque les décimales au lieu du .: gsub(\"\\\\,\", \"\\\\.\", data$V1) : remplace les , par un . pour convertir une chaine de caractères en numérique: as.numeric(data$V1) Par exemple: data &lt;- read.table(&quot;file.txt&quot;, header=TRUE, stringsAsFactors=FALSE) data$V1 &lt;- as.numeric(gsub(&quot;\\\\,&quot;, &quot;\\\\.&quot;, gsub(&quot;\\\\.&quot;, &quot;&quot;, data$V1))) les valeurs manquantes sont indiquées par .au lieu d’un vide: NA: read.table(\"file.txt\", header=TRUE, na.strings='.') précise le codage des vides. Si deux codages existent dans le fichier des . et les caractères NA : read.table(\"file.txt\", header=TRUE, na.strings=c('.', NA)) Nom de colonne manquant: R considère qu’une colonne sans nom contient les noms de lignes.read.table(\"file.csv\", header=TRUE, row.names=NULL) force la colonne sans nom à être prise comme une variable. Lignes de longueur différente: Si des lignes ont des longueurs différentes, R ne retrouve pas toutes les variables. Il faut le forcer par :read.table(\"file.csv\", header=TRUE, fill=TRUE) drop des premières lignes: On peut commencer la lecture du fichier au numéro de ligne souhaité: read.table(\"file.csv\", header=TRUE, skip=4): pour commencer à la ligne 5. Recommendations de lecture: - https://stats.idre.ucla.edu/stat/data/intro_r/intro_r_flat.html 5.2 Les packages R a une configuration de base, qui peut être complétée par de nombreux packages ajoutant différentes fonctions. Les packages doivent être installés une première fois sur le pc avant de pouvoir être utilisés. install.packages(\"pack\") téléchargera est installera le package.2 Les packages installés sur une machine ne sont pas chargés en mémoire au démarrage. On charge les packages requis dans l’environnement R par library() ou require() Les fonctions et les données contenus dans le package sont alors accessibles. Le package installrpropose la fonction updateR(), qui met automatiquement à jour la version de R et les packages. 5.3 Working directory: dossier de travail Sans précision particulière, les fichiers seront chargés et sauvegardés dans le working directory (wd): le dossier dans lequel R va stocker et rechercher les fichiers. Les fonctions getwd() et setwd() permettent respectivement de voir le dossier de travail actuel et de le modifier. R utilise un autre type d’écriture de chemin d’accès que celui de Windows (\"C:\\Dossier\\sous-dossier\"). Sous R, il faut utiliser \"C:/Dossier/sous-dossier\" ou \"C:\\\\Dossier\\\\sous-dossier\". Et sous Mac : \"/Users/Moi/Dossier/\" 5.4 Codage R: Le code R peut être saisi directement dans la console ligne à ligne ou être sauvé comme un script: une succession de lignes de code. Un script peut être sauvegardé dans un fichier d’extension .R. Un script peut être exécuté de plusieurs façons: en gardant le curseur sur la ligne à exécuter et en cliquant sur le bouton run (ou avec le raccourcis clavier CTRL+ENTREE). Après éxecution, le curseur passe à la ligne suivante. en sélectionnant la ou les lignes à exécuter et en cliquant sur run (ou CTRL+ENTREE) par la fonction source(\"monscript.R\"). Les commandes dans le script sont séparées soit par ; soit par un retour à la ligne R is case sensitive. Majuscules et minuscules sont prises en compte dans les noms de fonctions, d’objets, etc. Le caratère # précède des éléments de commentaires et ne sont pas exécutés. Certaines commandes s’étendent sur plusieurs lignes. On utilise + à la fin d’une ligne pour une commande multilignes. R stocke les données et les résultats dans des objets. On assigne et on stocke dans des objets avec l’opérateur &lt;-. Pour afficher le contenu d’un objet, il suffit d’exécuter son nom. Pour afficher tous les objets de l’environnement (ou la mémoire de R) : ls() Par exemple: # stocke 3 dans l&#39;objet abc abc &lt;- 3 # affiche le contenu de abc abc ## [1] 3 # affiche le contenu de l&#39;environnement ls() ## [1] &quot;a&quot; &quot;abc&quot; &quot;b&quot; &quot;char_vec&quot; &quot;mary_info&quot; ## [6] &quot;mon_vec&quot; &quot;Movie.Data&quot; &quot;mydata&quot; &quot;mylist&quot; &quot;scores&quot; Les fonctions sont essentielles pour le travail des données sous R. Comme pour les fonctions mathématiques, les fonction R réalisent des opérations sur un input et renvoient un output. Par exemple, la fonction mean(x) prend le vecteur de nombres x et renvoie leur moyenne. Les inputs sont souvent appelés des arguments de la fonction. L’aide et la documentation des fonctions et des objets de R sont accessibles par ? Par exemple ?mean 5.5 Structures de données Plusieurs types d’objets de R peuvent contenir des données. 5.6 Les Vecteurs Les vecteurs sont unidimentionnels et homogènes. Une variable seule peut être représentée par un vecteur de l’un des types suivants: - logical: la variable prend les valeurs TRUE ou FALSE (1 ou 0) - integer: un entier uniquement (représenté par un nombre suivi de L) - numeric ou double: un nombre réel - character: une chaine de caractères (du texte) Une valeur seule est un vecteur de longueur 1. c() est la fonction de concaténation. elle combine les valeurs de différents type en un vecteur. typeof() identifie le type du vecteur. length() renvoie la longueur du vecteur. Exemple: mon_vec &lt;- c(1, 3, 5) mon_vec ## [1] 1 3 5 typeof(mon_vec) ## [1] &quot;double&quot; char_vec &lt;- c(&quot;these&quot;, &quot;are&quot;, &quot;some&quot;, &quot;words&quot;) length(char_vec) ## [1] 4 Répétition et séquence rep() créé un vecteur en répétant les élements: seq() créé un vecteur en faisant une séquence d’éléments. L’expression m:n génère une séquence d’entiers de mà n Par exemple: # répéter 3 fois 0 rep(0, times=3) ## [1] 0 0 0 # répéter 4 fois &quot;abc&quot; rep(&quot;abc&quot;, 4) ## [1] &quot;abc&quot; &quot;abc&quot; &quot;abc&quot; &quot;abc&quot; # Séquence de 1 à 5 avec un pas de 2 seq(from=1, to=5, by=2) ## [1] 1 3 5 # Séquence de 10 à 0 avec un pas de -5 seq(10, 0, -5) ## [1] 10 5 0 # Séquence d&#39;entiers de 3 à 7 3:7 ## [1] 3 4 5 6 7 # Répétition de séquence: rep(seq(1,3,1), times=2) ## [1] 1 2 3 1 2 3 # Séquence de répétition rep(seq(1,3,1), each=2) ## [1] 1 1 2 2 3 3 5.7 Recyclage vectoriel Lorsque des opérations sont réalisées sur deux vecteurs ou plus, dont les dimensions sont inégales, les valeurs du vecteur le plus court seront ‘recyclées’ pour compléter le vecteur jusqu’à obtenir la même dimension que le vecteur le plus long. Dans l’exemple ci-dessous, le vecteur c(1) de taille 1 est recyclé pour devenir c(1,1,1) c(1,2,3) + 1 ## [1] 2 3 4 Ici, le vecteur c(1,2) est recyclé deux fois pour devenir c(1,2,1,2,1,2) c(1,2,3,4,5,6) + c(1,2) ## [1] 2 4 4 6 6 8 c(2) devient c(2,2,2) c(1,2,3) &lt; 2 ## [1] TRUE FALSE FALSE Si le recyclage est partiel, on a le message c(2,3,4) + c(10, 20) ## Warning in c(2, 3, 4) + c(10, 20): la taille d&#39;un objet plus long n&#39;est pas ## multiple de la taille d&#39;un objet plus court ## [1] 12 23 14 5.8 Sélectionner des sous-ensembles de vecteur avec [] Les éléments composant un vecteur peuvent être sélectionnés en spécifiant sa position dans le vecteur entre [] # créer un vecteur de 10 à 1 a &lt;- seq(10,1,-1) ; a ## [1] 10 9 8 7 6 5 4 3 2 1 Par exemple : Sélectionner le 2ème élément a[2] ## [1] 9 Sélectionner les 5 premiers éléments a[seq(1,5)] ## [1] 10 9 8 7 6 Sélection des premier, troisième et quatrième éléments: a[c(1,3,4)] ## [1] 10 8 7 Les éléments peuvent être nommés, et appelés par leur nom. scores &lt;- c(John=25, Marge=34, Dan=24, Emily=29) scores[c(&quot;John&quot;, &quot;Emily&quot;)] ## John Emily ## 25 29 5.9 Sélection conditionnelle - sous ensemble conditionné Le subsetting logique peut être fait avec un vecteur (TRUE/FALSE) scores[c(FALSE, TRUE, TRUE, FALSE)] ## Marge Dan ## 34 24 Il peut aussi être fait avec une condition scores[scores&lt;30] ## John Dan Emily ## 25 24 29 5.10 Listes Les listes sont des éléments uni-dimensionnels, mais dont les éléments peuvent être de types différents : des vecteurs (de toute dimension), des listes, des matrices, des dataframes. Une liste composée d’un vecteur, d’un vecteur d’entiers et un vecteur de caractères. mylist &lt;- list(1.1, c(1L,3L,7L), c(&quot;abc&quot;, &quot;def&quot;)) mylist ## [[1]] ## [1] 1.1 ## ## [[2]] ## [1] 1 3 7 ## ## [[3]] ## [1] &quot;abc&quot; &quot;def&quot; Les éléments peuvent être nommés mary_info &lt;- list(classes=c(&quot;Biology&quot;, &quot;Math&quot;, &quot;Music&quot;, &quot;Physics&quot;), friends=c(&quot;John&quot;, &quot;Dan&quot;, &quot;Emily&quot;), SAT=1450) mary_info ## $classes ## [1] &quot;Biology&quot; &quot;Math&quot; &quot;Music&quot; &quot;Physics&quot; ## ## $friends ## [1] &quot;John&quot; &quot;Dan&quot; &quot;Emily&quot; ## ## $SAT ## [1] 1450 Comme précédemment, l’accès aux composants d’une liste se fait soit par [[]] pour accèder avec la position, soit avec $ pour accèder avec le nom. Par la position mary_info[[2]] ## [1] &quot;John&quot; &quot;Dan&quot; &quot;Emily&quot; Par le nom mary_info$SAT ## [1] 1450 Le second élément du vecteur friend mary_info$friends[2] ## [1] &quot;Dan&quot; 5.11 Matrices Les matrices sont des structures de données à deux dimensions et homogènes. L’input de matrix() est un vecteur qui est transformé en une matrice en 2 dimensions, selon les spécifications nrow et ncol. Par défaut, la matrice est remplie colonne par colonne, cela est modifié par byrow=T Par exemple: une matrice 2lx3c, remplie par colonne: # on remplit les colonnes avec le vecteur de 1 à 6 sur 2 lignes a &lt;- matrix(1:6, nrow=2) a ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 Remplissage par ligne b &lt;- matrix(5:14, nrow=2, byrow=TRUE) b ## [,1] [,2] [,3] [,4] [,5] ## [1,] 5 6 7 8 9 ## [2,] 10 11 12 13 14 L’omission de row correspond à la sélection de toutes les lignes. L’omission de column sélectionne toutes les colonnes. Sélection de la ligne 2, colonne 3 a[2,3] ## [1] 6 Toutes les lignes de la colonne 2 b[,2] ## [1] 6 11 Toutes les colonnes de la ligne 1 a[1,] ## [1] 1 3 5 5.12 Dataframe Les données de l’analyse statistique sont typiquement stockées dans des dataframe. Elles combinent les possibilités des matrices et des listes. Comme pour les matrices, les dataframe sont rectangulaires, les colonnes sont les variables et les lignes sont les observations de ces variables. Comme les listes, les dataframe peuvent avoir des éléments (les colonnes) de différents types (numérique, caractère, facteurs, logique,etc.) Mais les éléments d’un dataframe doivent être de longueur égale. La syntaxe est la même que pour list(), mais les éléments doivent être de même longueur. Les éléments peuvent être nommés. Par exemple, un vecteur logique et un vecteur numérique mydata &lt;- data.frame(diabetic = c(TRUE, FALSE, TRUE, FALSE), height = c(65, 69, 71, 73)) mydata ## diabetic height ## 1 TRUE 65 ## 2 FALSE 69 ## 3 TRUE 71 ## 4 FALSE 73 Comme pour les matrices et les listes, les sélections sont faites avec[rows, columns] ou avec le nom de la variable. Par exemple mydata[3,2] ## [1] 71 Ou mydata[1:2, &quot;height&quot;] ## [1] 65 69 Ou mydata[,&quot;diabetic&quot;] ## [1] TRUE FALSE TRUE FALSE \\textbf{Accéder aux variables ou colonnes par le nom ou $} Par exemple mydata$height[2:3] ## [1] 69 71 mydata[[&quot;height&quot;]] ## [1] 65 69 71 73 mydata[[&quot;height&quot;]][2] ## [1] 69 colnames(data_frame) renvoie les noms des colonnes d’une dataframe (ou d’une matrice). colnames(data_frame) &lt;- c(\"some\", \"names\") assigne des noms aux colonnes. Par exemple colnames(mydata) ## [1] &quot;diabetic&quot; &quot;height&quot; colnames(mydata) &lt;- c(&quot;Diabetic&quot;, &quot;Height&quot;) colnames(mydata) ## [1] &quot;Diabetic&quot; &quot;Height&quot; Pour changer le nom d’une variable: colnames(mydata)[1] &lt;- &quot;Diabetes&quot; colnames(mydata) ## [1] &quot;Diabetes&quot; &quot;Height&quot; Enfin on peut “copier/coller” une variable sous condition : dat[dat$Subject=='s2',]$RT &lt;- dat[dat$Subject=='s2',]$Trial Pour les objets à 2 dimensions dim() renvoie le nombre de lignes et de colonnes. On utilise str() pour connaître la structure d’un objet et le type de ses éléments. dim(mydata) ## [1] 4 2 str(mydata) ## &#39;data.frame&#39;: 4 obs. of 2 variables: ## $ Diabetes: logi TRUE FALSE TRUE FALSE ## $ Height : num 65 69 71 73 5.13 Manipulation de données Débutant avec R, il peut sembler efficace de manipuler les données avec un logiciel familier tel que MS Excel, pour corriger les erreurs, ajouter quelques informations ou faire quelques calculs simples. Pourtant, le travail sous R est encouragé ici, pour 100% des opérations sur les données ! Quelques arguments: MS Excel charge les données réelles, ce qui signifie que les modifications sont sauvegardées dans le fichier de données même. De plus, aucun historique des manipulations n’est sauvegardé, il est donc difficile, voire impossible, de conserver une trace des changements. Au contraire, R, charge une copie des données dans sa mémoire et n’altère pas directement les données. Il permet de fonctionner avec des scripts, qui listent les manipulations appliquées aux données, les rendant ainsi reproductibles et transparentes. Travailler directement sur les données peut produire des erreurs qui sont alors difficiles à identifier et à corriger. Avec R il est facile de détecter les erreurs et problèmes systématiques à partir de petits programmes. Différents formats de données peuvent être chargés avec R, notamment les formats de logiciels spécialisés tels que SAS, Spss, Stata, etc. Dataframe Une base de données sous R est appelée une dataframe, équivalent à une matrice de données où les lignes sont indéxées par leur numéro et les colonnes par des noms de variables. Les bases de données d’autres formats (par ex. ceux d’autres logiciels) peuvent être importées (ou chargées) sous R. Formats de données R Les fichiers .Rdata ou .rda contiennent un ou plusieurs objets R (dataframes, fonctions, shapefiles, etc.) # Chargement d&#39;un fichier (fictif) de données dans R: load(&#39;DATA\\\\Movie.Data.Clean.RData&#39;) # utiliser ls() pour lister les objets de l&#39;environnement ls() ## [1] &quot;a&quot; &quot;abc&quot; &quot;b&quot; &quot;char_vec&quot; &quot;mary_info&quot; ## [6] &quot;mon_vec&quot; &quot;Movie.Data&quot; &quot;mydata&quot; &quot;mylist&quot; &quot;scores&quot; Les fichiers .rds contiennent un objet R sans nom. Cet objet est donc stocké dans une seule variable. readRDS('file.rds') permet de charger un tel fichier et str(newdat)de savoir quels objets sont dans l’objet chargé. Les fichers texte Les fichiers .txtou .csv sont des fichiers de données brutes, sans mise en forme des données (par exemple format de date). Dans un fichier texte, une ligne correspond à une observation (une ligne du dataframe). Sur la ligne, les valeurs des différentes colonnes sont séparées par un caractère séparateur (souvent le ; ou la tabulation). read.table('file.txt', header=TRUE) permet de charger un fichier texte où la 1ère ligne contient les noms de variables. Problèmes classiques de lecture des fichiers textes R ne trouve pas le fichier que vous voulez charger: Vérifiez votre working directory (dossier de travail) getwd(). Ce dossier contient-il le fichier que vous voulez charger ? Modifiez ce dossier avec setwd(). Parfois il est utile de préciser tout le chemin d’accès dans le nom du fichier à charger. Par exemple: \"C://Documents//data.txt\" sous Windows ou sous Mac \"/Users/Moi/Documents/data.txt\". Incorrect delimiter. Aucun message d’erreur n’est affiché, mais les données paraissent étranges. Le séparateur de variable est mal spécifié. Excel utilise souvent la , alors que d’autres logiciels utilisent l’espace ou la tabulation. dat &lt;- read.table(\"file.csv\", header=TRUE, sep=',')permet de préciser le séparateur. Décimale. Les données issues de locigiels anglosaxons utilisent le . pour indiquer les décimales, plutôt que la ,. Cela peut être précisé avec: dat &lt;- read.table(\"file.csv\", header=TRUE, sep=',', dec='.') Cependant, le . est aussi parfois utilisé pour séparer les milliers. C’est alors à l’exportation des données que l’on doit s’assurer du caractère des décimales et qu’il n’y a pas de caractère pour les milliers. Erreurs sur les variables. Dans certains cas, le problème d’importation affecte une ou plusieurs variables. Une chaine de caractère est reconnue comme un facteur : as.character(data$V1) pour convertir une variable en caractère. Dans un champs de caractère, le . est utilisé pour les milliers, alors que la ,marque les décimales. gsub(\"\\\\.\", \"\", data$V1)supprime les . dans le champs de valeurs. La ,marque les décimales au lieu du .: gsub(\"\\\\,\", \"\\\\.\", data$V1) : remplace les , par un . pour convertir une chaine de caractères en numérique: as.numeric(data$V1) Par exemple: data &lt;- read.table(&quot;file.txt&quot;, header=TRUE, stringsAsFactors=FALSE) data$V1 &lt;- as.numeric(gsub(&quot;\\\\,&quot;, &quot;\\\\.&quot;, gsub(&quot;\\\\.&quot;, &quot;&quot;, data$V1))) les valeurs manquantes sont indiquées par .au lieu d’un vide: NA: read.table(\"file.txt\", header=TRUE, na.strings='.') précise le codage des vides. Si deux codages existent dans le fichier des . et les caractères NA : read.table(\"file.txt\", header=TRUE, na.strings=c('.', NA)) Nom de colonne manquant: R considère qu’une colonne sans nom contient les noms de lignes.read.table(\"file.csv\", header=TRUE, row.names=NULL) force la colonne sans nom à être prise comme une variable. Lignes de longueur différente: Si des lignes ont des longueurs différentes, R ne retrouve pas toutes les variables. Il faut le forcer par :read.table(\"file.csv\", header=TRUE, fill=TRUE) drop des premières lignes: On peut commencer la lecture du fichier au numéro de ligne souhaité: read.table(\"file.csv\", header=TRUE, skip=4): pour commencer à la ligne 5. voir le fichier install.packages.R qui regroupe les packages utilisés pour ce cours et ceux conseillés.↩ "],
["methods.html", "Chapter 6 Methods", " Chapter 6 Methods We describe our methods in this chapter. "],
["applications.html", "Chapter 7 Applications 7.1 Example one 7.2 Example two", " Chapter 7 Applications Some significant applications are demonstrated in this chapter. 7.1 Example one 7.2 Example two "],
["final-words.html", "Chapter 8 Final Words", " Chapter 8 Final Words We have finished a nice book. "],
["references.html", "References", " References "]
]
